Рассмотрим пример использования свойств объектов для реализации операции символьного дифферинцирования формул.
Свободная переменная будет обозначена символом x, формулы записываться в префиксной форме, т.е. 1 + х будет выглядеть как (+ 1 х).
Идея реализации состоит в том, что каждый оператор представлен объектом со свойством, которое содержит специфичную для него ф-цию дифференцирования.
Следующий код реализует правила (a + b)' = a' + b' и (ab)' = a'b + ab':

(setf (get 'op+ 'df)
	(lambda (a b) (list 'op+ (df a) (df b))))

(setf (get 'op* 'df)
	(lambda (a b) (list 'op+ (list 'op* (df a) b) (list 'op* (df b) a))))

(defun df (expr)
	(when expr
		(cond
			((listp expr)										;выражение вида (оператор операнд-1 операнд-2)
				(let* ((op (car expr)) (f (get op 'df)))
					(funcall f (second expr) (third expr))))
			((eq expr 'x) 1)									;xdx = 1
			(t 0)												;не выражение и не свободная переменная => константа
	)))

Тогда:

>> (df (list 'op+ 1 (list 'op* 2 'x)))
(OP+ 0 (OP+ (OP* 0 X) (OP* 1 2)))

Задание:
1. Реализовать правила (a - b)' = a' - b', (a/b)' = (a'b - b'a)/(bb).
2. Переписать пример так, что бы можно было использовать не только бинарные, но и унарные операторы, реализовать правила:
	sin'(x) = cos(x)
	cos'(x) = - sin(x)
3. Применяя проиллюстрированый подход, написать функцию simplify, принимающую на вход выражения того же вида что и df и упрощающую их по правилам:
	a - 0 = a
	0 + a = a
	a + 0 = a
	0 * a = 0
	a * 0 = 0
	1 * a = a
	a * 1 = a
	a / 1 = a
	0 / a = 0
	a + b = c, где a, b - числа, с - их сумма
	a - b = c, где a, b - числа, с - их разность
	a * b = c, где a, b - числа, с - их произведение
	a / b = c, где a, b - числа, с - их частное

!!!Update:
1. Списки, возвращаемые df и simplify, должны быть представлены в той же нотации что и входные списки. Т.е. должна быть возможность несколько раз применить df: (df (df ...)), например
2. simplify должна возвращать список, повторное применение simplify к которому не приведет к изменению результата.

